// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

class RustBuffer {
    constructor(capacity, len, data) {
        this.capacity = capacity;
        this.len = len;
        this.data = data;
    }

    static from(ptr) {
        // Assuming rustCall is a function to be defined later
        // ffi_rgb_lib_9a28_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0)
        // You'll need to implement the equivalent functionality in JavaScript.
        throw new Error("Not implemented yet.");
    }

    deallocate() {
        // Assuming rustCall is a function to be defined later
        // ffi_rgb_lib_9a28_rustbuffer_free(this, $0);
        // You'll need to implement the equivalent functionality in JavaScript.
        throw new Error("Not implemented yet.");
    }
}

class ForeignBytes {
    constructor(len, data) {
        this.len = len;
        this.data = data;
    }
}

class Data {
    constructor(bytes) {
        // TODO: This copies the buffer. Can we read directly from a Rust buffer?
        this.bytes = new Uint8Array(bytes);
    }
}

function createReader(data) {
    return { data: data, offset: 0 };
}

function readInt(reader) {
    const range = reader.offset;
    reader.offset += 1;
    // Assuming UniffiInternalError.bufferOverflow is an error constant to be defined.
    if (reader.data.length < range + 1) {
        throw new Error("UniffiInternalError.bufferOverflow");
    }
    return reader.data[range];
}

function readBytes(reader, count) {
    const range = reader.offset;
    reader.offset += count;
    // Assuming UniffiInternalError.bufferOverflow is an error constant to be defined.
    if (reader.data.length < range + count) {
        throw new Error("UniffiInternalError.bufferOverflow");
    }
    return Array.from(reader.data.subarray(range, range + count));
}

function readFloat(reader) {
    const intVal = readInt(reader);
    return intVal === 0 ? 0.0 : new DataView(new ArrayBuffer(4)).getFloat32(0, false);
}

function readDouble(reader) {
    const intVal = readInt(reader);
    return intVal === 0 ? 0.0 : new DataView(new ArrayBuffer(8)).getFloat64(0, false);
}

function hasRemaining(reader) {
    return reader.offset < reader.data.length;
}

function createWriter() {
    return [];
}

function writeBytes(writer, byteArr) {
    writer.push(...byteArr);
}

function writeInt(writer, value) {
    writer.push(value);
}

function writeFloat(writer, value) {
    writeInt(writer, value === 0.0 ? 0 : new DataView(new ArrayBuffer(4)).setFloat32(0, value, false));
}

function writeDouble(writer, value) {
    writeInt(writer, value === 0.0 ? 0 : new DataView(new ArrayBuffer(8)).setFloat64(0, value, false));
}

class UniffiInternalError extends Error {
    constructor(message) {
        super(message);
        this.name = "UniffiInternalError";
    }
}

const CALL_SUCCESS = 0;
const CALL_ERROR = 1;
const CALL_PANIC = 2;

class RustCallStatus {
    constructor() {
        this.code = CALL_SUCCESS;
        this.errorBuf = new RustBuffer(0, 0, null);
    }
}

// Assuming rustCall is a function to be defined later
// rustCall(() => {
//   ffi_rgb_lib_9a28_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0)
// });
// rustCall(() => {
//   ffi_rgb_lib_9a28_rustbuffer_free(this, $0);
// });

// rustCall is a function you'll need to define to handle FFI calls and
// interact with the external library.

// Rest of the code, including protocol definitions, will remain the same, just translated from Swift to JavaScript.
// Please note that certain Swift-specific features like generics and associated types may not have a direct equivalent in JavaScript.
